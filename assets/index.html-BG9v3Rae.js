import{_ as o,c as e,a as r,o as a}from"./app-Dm747Kgg.js";const i={};function n(l,t){return a(),e("div",null,t[0]||(t[0]=[r('<p>老年代（Old Generation）是JVM堆内存中用于存储<strong>存活时间较长</strong>对象的内存区域，是堆内存分代回收策略的重要组成部分。以下是其核心特点和工作机制：</p><h3 id="一、定义与位置" tabindex="-1"><a class="header-anchor" href="#一、定义与位置"><span>一、定义与位置</span></a></h3><ul><li><strong>位置</strong>：老年代与年轻代共同构成JVM堆内存（部分JVM实现还包含元空间/永久代，但它们属于方法区，不属于堆内存）</li><li><strong>作用</strong>：专门存放经过多次Minor GC仍存活的对象，以及部分特殊情况下直接分配的大对象</li></ul><h3 id="二、核心特点" tabindex="-1"><a class="header-anchor" href="#二、核心特点"><span>二、核心特点</span></a></h3><ol><li><strong>空间占比大</strong>：通常老年代空间远大于年轻代（默认比例为2:1，即老年代占堆内存的2/3，年轻代占1/3）</li><li><strong>GC频率低</strong>：由于存储的是长寿命对象，老年代的垃圾回收频率远低于年轻代</li><li><strong>回收速度慢</strong>：老年代GC（Major GC/Full GC）采用标记-清除或标记-整理算法，单次回收耗时较长</li><li><strong>内存碎片敏感</strong>：长期使用后容易产生内存碎片，影响内存分配效率</li></ol><h3 id="三、对象进入老年代的条件" tabindex="-1"><a class="header-anchor" href="#三、对象进入老年代的条件"><span>三、对象进入老年代的条件</span></a></h3><p>对象从年轻代晋升到老年代主要有以下几种情况：</p><ol><li><strong>年龄阈值</strong>：对象在年轻代的Survivor区中每经历一次Minor GC，年龄计数器加1，当年龄达到阈值（默认15，可通过<code>-XX:MaxTenuringThreshold</code>调整）时晋升</li><li><strong>大对象直接进入</strong>：超过一定大小的对象（可通过<code>-XX:PretenureSizeThreshold</code>参数配置）会绕过年轻代，直接分配到老年代</li><li><strong>动态年龄判定</strong>：如果Survivor区中相同年龄的对象大小总和超过Survivor区的一半，年龄大于等于该年龄的对象将直接晋升</li><li><strong>年轻代空间分配担保</strong>：在Minor GC前，JVM会检查老年代剩余空间是否足够容纳年轻代所有对象，若不足则可能触发Full GC</li></ol><h3 id="四、老年代的垃圾回收" tabindex="-1"><a class="header-anchor" href="#四、老年代的垃圾回收"><span>四、老年代的垃圾回收</span></a></h3><ul><li><strong>回收类型</strong>：称为<strong>Major GC</strong>（仅回收老年代）或<strong>Full GC</strong>（同时回收年轻代和老年代）</li><li><strong>回收算法</strong>：通常采用<strong>标记-清除算法</strong>或<strong>标记-整理算法</strong><ul><li>标记-清除：效率较高但产生碎片</li><li>标记-整理：无碎片但整理阶段耗时较长</li></ul></li><li><strong>触发条件</strong>： <ul><li>老年代空间不足</li><li>显式调用<code>System.gc()</code>（不推荐）</li><li>年轻代空间分配担保失败</li><li>元空间（Metaspace）不足</li></ul></li></ul><h3 id="五、jvm参数配置" tabindex="-1"><a class="header-anchor" href="#五、jvm参数配置"><span>五、JVM参数配置</span></a></h3><ul><li><code>-Xmx</code>：设置堆内存最大值（包含年轻代和老年代）</li><li><code>-Xms</code>：设置堆内存初始值</li><li><code>-XX:NewRatio</code>：设置年轻代与老年代的比例（如<code>-XX:NewRatio=2</code>表示年轻代:老年代=1:2）</li><li><code>-XX:OldSize</code>：设置老年代初始大小</li><li><code>-XX:MaxOldSize</code>：设置老年代最大值</li><li><code>-XX:MaxTenuringThreshold</code>：设置对象晋升老年代的年龄阈值</li></ul><h3 id="六、与年轻代的关系" tabindex="-1"><a class="header-anchor" href="#六、与年轻代的关系"><span>六、与年轻代的关系</span></a></h3><p>老年代与年轻代共同构成完整的堆内存分代模型，基于<strong>弱分代假说</strong>（多数对象朝生夕死）和<strong>强分代假说</strong>（熬过越多次GC的对象越难被回收）设计。这种分代策略可以：</p><ol><li>提高GC效率：针对不同区域采用不同回收算法</li><li>减少停顿时间：年轻代GC速度快，影响小</li><li>优化内存分配：根据对象生命周期特点分配不同区域</li></ol>',15)]))}const c=o(i,[["render",n],["__file","index.html.vue"]]),d=JSON.parse(`{"path":"/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/162803/","title":"什么是老年代","lang":"zh-CN","frontmatter":{"title":"什么是老年代","createTime":"2025/12/29 16:28:03","permalink":"/doc/Java/JVM/分代分区/162803/","copyright":{"author":{"name":"Hu Bao","url":"https://github.com/hubao-1125"}},"tags":["JVM","面试题"],"description":"老年代（Old Generation）是JVM堆内存中用于存储存活时间较长对象的内存区域，是堆内存分代回收策略的重要组成部分。以下是其核心特点和工作机制： 一、定义与位置 位置：老年代与年轻代共同构成JVM堆内存（部分JVM实现还包含元空间/永久代，但它们属于方法区，不属于堆内存） 作用：专门存放经过多次Minor GC仍存活的对象，以及部分特殊情况下...","head":[["meta",{"property":"og:url","content":"https://hubao-1125.github.io/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/162803/"}],["meta",{"property":"og:site_name","content":"Hu bao's blog"}],["meta",{"property":"og:title","content":"什么是老年代"}],["meta",{"property":"og:description","content":"老年代（Old Generation）是JVM堆内存中用于存储存活时间较长对象的内存区域，是堆内存分代回收策略的重要组成部分。以下是其核心特点和工作机制： 一、定义与位置 位置：老年代与年轻代共同构成JVM堆内存（部分JVM实现还包含元空间/永久代，但它们属于方法区，不属于堆内存） 作用：专门存放经过多次Minor GC仍存活的对象，以及部分特殊情况下..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-29T09:26:08.000Z"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2025-12-29T09:26:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"什么是老年代\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-29T09:26:08.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":2.96,"words":889},"git":{"updatedTime":1767000368000,"contributors":[{"name":"hubao-1125","username":"hubao-1125","email":"19473254+hubao-1125@users.noreply.github.com","commits":1,"avatar":"https://avatars.githubusercontent.com/hubao-1125?v=4","url":"https://github.com/hubao-1125"}]},"autoDesc":true,"filePathRelative":"doc/Java/JVM/分代分区/19.什么是老年代.md","categoryList":[{"id":"9a09b4","sort":10000,"name":"doc"},{"id":"8f1aa6","sort":10001,"name":"Java"},{"id":"000f90","sort":10002,"name":"JVM"},{"id":"2b6b47","sort":10003,"name":"分代分区"}]}`);export{c as comp,d as data};
