import{_ as t,c as e,a as s,o}from"./app-Dm747Kgg.js";const n={};function r(l,a){return o(),e("div",null,a[0]||(a[0]=[s('<p>虚拟机栈（JVM Stack）是Java虚拟机（JVM）内存模型中<strong>线程私有的内存区域</strong>，主要用于<strong>支持Java方法的调用、执行和返回</strong>，是方法运行时的基础数据结构。</p><h3 id="一、虚拟机栈的核心特性" tabindex="-1"><a class="header-anchor" href="#一、虚拟机栈的核心特性"><span>一、虚拟机栈的核心特性</span></a></h3><ol><li><strong>线程私有</strong>：每个Java线程创建时会独立分配一个虚拟机栈，线程间的栈内存相互隔离，互不影响。</li><li><strong>后进先出（LIFO）</strong>：栈结构遵循“后进先出”原则，方法调用时压入栈帧，方法结束时弹出栈帧。</li><li><strong>自动内存管理</strong>：栈内存的分配与回收<strong>无需GC介入</strong>，随方法的调用（分配栈帧）和结束（释放栈帧）自动进行。</li></ol><h3 id="二、虚拟机栈的基本组成单位-栈帧-stack-frame" tabindex="-1"><a class="header-anchor" href="#二、虚拟机栈的基本组成单位-栈帧-stack-frame"><span>二、虚拟机栈的基本组成单位：栈帧（Stack Frame）</span></a></h3><p>栈帧是虚拟机栈的最小单元，<strong>每个方法的调用都会创建一个栈帧</strong>，并压入虚拟机栈；方法执行结束（正常返回或异常抛出）时，栈帧从栈顶弹出并销毁。一个栈帧包含以下核心信息：</p><h4 id="_1-局部变量表-local-variable-table" tabindex="-1"><a class="header-anchor" href="#_1-局部变量表-local-variable-table"><span>1. 局部变量表（Local Variable Table）</span></a></h4><ul><li><strong>作用</strong>：存储方法执行过程中的<strong>局部变量</strong>，包括方法参数、基本数据类型变量（boolean、byte、char、short、int、float、long、double）和对象引用（reference类型）。</li><li><strong>容量</strong>：以“变量槽（Slot）”为单位，一个Slot可存储一个32位数据（如int、float），64位数据（long、double）占用2个Slot。</li><li><strong>特性</strong>：局部变量表在编译期就已确定大小（写入class文件的Code属性中），方法运行时不会改变。</li></ul><h4 id="_2-操作数栈-operand-stack" tabindex="-1"><a class="header-anchor" href="#_2-操作数栈-operand-stack"><span>2. 操作数栈（Operand Stack）</span></a></h4><ul><li><strong>作用</strong>：作为方法执行的<strong>临时数据存储区</strong>，用于存放计算过程中的中间结果和操作数。</li><li><strong>特点</strong>： <ul><li>遵循“栈”结构（后进先出），通过压栈（push）和出栈（pop）操作访问。</li><li>执行字节码指令时，操作数栈与局部变量表配合完成运算（如<code>iadd</code>指令从操作数栈弹出两个int值相加，再压回结果）。</li></ul></li><li><strong>容量</strong>：同样在编译期确定，写入class文件的Code属性中。</li></ul><h4 id="_3-动态链接-dynamic-linking" tabindex="-1"><a class="header-anchor" href="#_3-动态链接-dynamic-linking"><span>3. 动态链接（Dynamic Linking）</span></a></h4><ul><li><strong>作用</strong>：将方法运行时的<strong>符号引用</strong>（class文件中的方法名、字段名等）转换为<strong>直接引用</strong>（方法在内存中的实际地址）。</li><li><strong>意义</strong>：支持Java的多态特性（如方法重写），确保调用的是实际对象的方法实现。</li></ul><h4 id="_4-方法出口-return-address" tabindex="-1"><a class="header-anchor" href="#_4-方法出口-return-address"><span>4. 方法出口（Return Address）</span></a></h4><ul><li><strong>作用</strong>：记录方法返回后<strong>继续执行的位置</strong>（即调用该方法的字节码指令的下一条指令地址）。</li><li><strong>两种返回场景</strong>： <ul><li>正常返回：通过<code>ireturn</code>、<code>lreturn</code>等指令返回，方法出口指向调用者的下一条指令。</li><li>异常返回：通过异常处理表（Exception Table）跳转，不依赖方法出口字段。</li></ul></li></ul><h3 id="三、虚拟机栈的大小与异常" tabindex="-1"><a class="header-anchor" href="#三、虚拟机栈的大小与异常"><span>三、虚拟机栈的大小与异常</span></a></h3><ol><li><p><strong>大小控制</strong><br> 虚拟机栈的大小可通过JVM参数<code>-Xss</code>调整（默认约1MB），例如：</p><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki material-theme-ocean vp-code"><code><span class="line"><span style="color:#FFCB6B;">java</span><span class="space"> </span><span style="color:#C3E88D;">-Xss256k</span><span class="space"> </span><span style="color:#C3E88D;">MyApp</span><span class="space"> </span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">#</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">设置每个线程的栈大小为256KB</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>常见异常</strong></p><ul><li><strong>StackOverflowError</strong>：当方法递归调用层级过深（栈帧数量超过栈的最大深度）时抛出，例如无限递归。</li><li><strong>OutOfMemoryError</strong>：当线程请求分配虚拟机栈内存时，若系统内存不足，无法创建新的栈帧，会抛出此异常（如创建大量线程时）。</li></ul></li></ol><h3 id="四、虚拟机栈与本地方法栈的区别" tabindex="-1"><a class="header-anchor" href="#四、虚拟机栈与本地方法栈的区别"><span>四、虚拟机栈与本地方法栈的区别</span></a></h3><p>虚拟机栈为<strong>Java方法</strong>服务，而<strong>本地方法栈（Native Method Stack）<strong>为</strong>Native方法</strong>（使用C/C++实现的方法，如<code>System.currentTimeMillis()</code>）服务。部分JVM实现（如HotSpot）会将两者合并为同一内存区域，但概念上仍需区分。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>虚拟机栈是Java方法执行的“工作台”，通过栈帧的压入和弹出来管理方法的调用生命周期，其线程私有性和自动内存管理机制确保了Java方法执行的隔离性和高效性。</p>',19)]))}const c=t(n,[["render",r],["__file","index.html.vue"]]),p=JSON.parse(`{"path":"/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/142831/","title":"什么是虚拟机栈","lang":"zh-CN","frontmatter":{"title":"什么是虚拟机栈","createTime":"2025/12/23 14:28:31","permalink":"/doc/Java/JVM/分代分区/142831/","copyright":{"author":{"name":"Hu Bao","url":"https://github.com/hubao-1125"}},"tags":["JVM","面试题"],"description":"虚拟机栈（JVM Stack）是Java虚拟机（JVM）内存模型中线程私有的内存区域，主要用于支持Java方法的调用、执行和返回，是方法运行时的基础数据结构。 一、虚拟机栈的核心特性 线程私有：每个Java线程创建时会独立分配一个虚拟机栈，线程间的栈内存相互隔离，互不影响。 后进先出（LIFO）：栈结构遵循“后进先出”原则，方法调用时压入栈帧，方法结束...","head":[["meta",{"property":"og:url","content":"https://hubao-1125.github.io/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/142831/"}],["meta",{"property":"og:site_name","content":"Hu bao's blog"}],["meta",{"property":"og:title","content":"什么是虚拟机栈"}],["meta",{"property":"og:description","content":"虚拟机栈（JVM Stack）是Java虚拟机（JVM）内存模型中线程私有的内存区域，主要用于支持Java方法的调用、执行和返回，是方法运行时的基础数据结构。 一、虚拟机栈的核心特性 线程私有：每个Java线程创建时会独立分配一个虚拟机栈，线程间的栈内存相互隔离，互不影响。 后进先出（LIFO）：栈结构遵循“后进先出”原则，方法调用时压入栈帧，方法结束..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-23T06:34:42.000Z"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2025-12-23T06:34:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"什么是虚拟机栈\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-23T06:34:42.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":3.42,"words":1025},"git":{"updatedTime":1766471682000,"contributors":[{"name":"hubao-1125","username":"hubao-1125","email":"19473254+hubao-1125@users.noreply.github.com","commits":1,"avatar":"https://avatars.githubusercontent.com/hubao-1125?v=4","url":"https://github.com/hubao-1125"}]},"autoDesc":true,"filePathRelative":"doc/Java/JVM/分代分区/10.什么是虚拟机栈.md","categoryList":[{"id":"9a09b4","sort":10000,"name":"doc"},{"id":"8f1aa6","sort":10001,"name":"Java"},{"id":"000f90","sort":10002,"name":"JVM"},{"id":"2b6b47","sort":10003,"name":"分代分区"}]}`);export{c as comp,p as data};
