import{_ as a,c as r,a as o,o as e}from"./app-Dm747Kgg.js";const i={};function n(l,t){return e(),r("div",null,t[0]||(t[0]=[o('<h3 id="jvm-的内存模型详解" tabindex="-1"><a class="header-anchor" href="#jvm-的内存模型详解"><span>JVM 的内存模型详解</span></a></h3><p>在 Java 开发中，“JVM 的内存模型”通常有两种常见指代：</p><ol><li><strong>JVM 运行时内存结构</strong>（也称 JVM 内存区域划分），这是《Java 虚拟机规范》定义的程序运行时数据区，主要描述 JVM 如何划分和管理内存。</li><li><strong>Java 内存模型（Java Memory Model，简称 JMM）</strong>，这是 Java 语言规范（JLS 第 17 章）定义的抽象模型，主要解决多线程环境下共享变量的可见性、有序性和原子性问题。</li></ol><p>很多人会混淆两者，但它们是不同的概念。（基于当前最新 Java 版本，如 Java 21/22，核心结构未发生根本变化）。</p><h4 id="_1-jvm-运行时内存结构-runtime-data-areas" tabindex="-1"><a class="header-anchor" href="#_1-jvm-运行时内存结构-runtime-data-areas"><span>1. JVM 运行时内存结构（Runtime Data Areas）</span></a></h4><p>JVM 在执行 Java 程序时，将管理的内存划分为几个运行时数据区。这些区域有线程私有和线程共享之分。</p><table><thead><tr><th>区域名称</th><th>线程私有/共享</th><th>主要作用</th><th>可能异常</th><th>备注（Java 8+ 变化）</th></tr></thead><tbody><tr><td><strong>程序计数器 (Program Counter Register)</strong></td><td>私有</td><td>记录当前线程执行的字节码指令地址（用于分支、循环、异常处理等）。如果执行 native 方法，则值为 undefined。</td><td>无（空间很小）</td><td>线程私有，随线程生灭</td></tr><tr><td><strong>Java 虚拟机栈 (Java Virtual Machine Stack)</strong></td><td>私有</td><td>每个方法执行时创建一个<strong>栈帧</strong>（Stack Frame），存储局部变量表、操作数栈、动态链接、方法出口等。方法调用对应栈帧入栈，方法返回对应出栈。</td><td>StackOverflowError（栈深度超限）<br>OutOfMemoryError（无法扩展）</td><td>可通过 -Xss 设置栈大小</td></tr><tr><td><strong>本地方法栈 (Native Method Stack)</strong></td><td>私有</td><td>类似虚拟机栈，但服务于 native 方法（JNI 调用）。有些 JVM 合并为一个栈。</td><td>同虚拟机栈</td><td></td></tr><tr><td><strong>堆 (Heap)</strong></td><td>共享</td><td>存储所有对象实例、数组。几乎所有对象都在这里分配（逃逸分析优化可能栈上分配）。分为新生代（Eden + Survivor）和老年代。</td><td>OutOfMemoryError</td><td>GC 主要管理区域。可通过 -Xms/-Xmx 设置大小</td></tr><tr><td><strong>方法区 (Method Area)</strong></td><td>共享</td><td>存储类信息、常量、静态变量、JIT 编译后的代码等。Java 8 前称为永久代（PermGen），Java 8+ 改为<strong>元空间 (Metaspace)</strong>，使用本地内存（Native Memory），不再受堆限制。运行时常量池也在此。</td><td>OutOfMemoryError (Metaspace)</td><td>可通过 -XX:MaxMetaspaceSize 设置</td></tr></tbody></table><ul><li><p><strong>堆的细分（HotSpot JVM 示例）</strong>：</p><ul><li>新生代：Eden（大部分新对象分配这里） + From/To Survivor（Minor GC 时存活对象复制）。</li><li>老年代：长期存活对象。</li><li>TLAB（Thread Local Allocation Buffer）：为避免多线程分配冲突，每个线程在 Eden 区有私有缓冲区，提高分配效率。</li></ul></li><li><p><strong>直接内存 (Direct Memory)</strong>：不属于以上区域，通过 NIO 的 ByteBuffer.directAllocate() 分配，受本地内存限制，可能导致 OutOfMemoryError。</p></li></ul><h4 id="_2-java-内存模型-jmm" tabindex="-1"><a class="header-anchor" href="#_2-java-内存模型-jmm"><span>2. Java 内存模型（JMM）</span></a></h4><p>JMM 是抽象规范，不是实际内存划分。它定义了线程如何与内存交互，解决多线程下共享变量的<strong>可见性</strong>、<strong>有序性</strong>和<strong>原子性</strong>问题。</p><ul><li><p><strong>核心抽象</strong>：</p><ul><li><strong>主内存 (Main Memory)</strong>：存储所有共享变量的“真实”值（线程共享）。</li><li><strong>工作内存 (Local Memory)</strong>：每个线程私有，存储该线程使用的共享变量副本（抽象概念，包括 CPU 缓存、寄存器等）。</li></ul></li><li><p><strong>线程操作共享变量的 8 种原子操作</strong>（必须原子执行）：</p><ol><li>lock / unlock：锁定/解锁主内存变量。</li><li>read / load：从主内存读到工作内存。</li><li>use / assign：工作内存使用/赋值。</li><li>store / write：从工作内存写回主内存。</li></ol></li><li><p><strong>问题来源</strong>：</p><ul><li>CPU 缓存导致可见性问题（一个线程修改，另一个线程缓存旧值）。</li><li>编译器/处理器指令重排序（优化性能，但可能破坏单线程语义外的有序性）。</li></ul></li><li><p><strong>关键保证：happens-before 规则</strong>（如果 A happens-before B，则 A 的结果对 B 可见，且 A 有序先于 B）：</p><ul><li>程序顺序规则：同一线程内，按代码顺序。</li><li>监视器锁规则：unlock 先于后续 lock。</li><li>volatile 规则：对 volatile 变量的写 先于 读。</li><li>线程启动规则：Thread.start() 先于线程内操作。</li><li>线程终止规则：线程内操作 先于 join() 返回。</li><li>传递性：A hb B，B hb C ⇒ A hb C。</li><li>final 规则：final 字段初始化完成后可见。</li></ul></li><li><p><strong>同步机制</strong>：</p><ul><li><strong>volatile</strong>：保证可见性和有序性（禁止重排序），但不保证原子性。</li><li><strong>synchronized</strong>：保证原子性、可见性和有序性。</li><li><strong>final</strong>：初始化安全，保证不可变性。</li><li><strong>Lock / Atomic 类</strong>：基于 JMM 实现更高级并发。</li></ul></li></ul><p>JMM 允许重排序（不影响单线程结果），但通过 happens-before 确保正确同步的多线程程序结果一致。</p><h4 id="总结与区别" tabindex="-1"><a class="header-anchor" href="#总结与区别"><span>总结与区别</span></a></h4><ul><li><strong>JVM 运行时内存结构</strong>：物理/逻辑划分，关注“哪里存数据”（堆存对象、栈存局部变量）。</li><li><strong>JMM</strong>：并发抽象模型，关注“多线程如何安全读写共享变量”（可见性等）。</li><li>两者关系：JMM 建立在 JVM 内存结构之上，利用堆（共享变量）和线程私有栈/缓存实现。</li></ul>',14)]))}const d=a(i,[["render",n],["__file","index.html.vue"]]),p=JSON.parse(`{"path":"/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/165450/","title":"JVM内存模型","lang":"zh-CN","frontmatter":{"title":"JVM内存模型","createTime":"2025/12/19 16:54:50","permalink":"/doc/Java/JVM/分代分区/165450/","copyright":{"author":{"name":"Hu Bao","url":"https://github.com/hubao-1125"}},"tags":["JVM","面试题"],"description":"JVM 的内存模型详解 在 Java 开发中，“JVM 的内存模型”通常有两种常见指代： JVM 运行时内存结构（也称 JVM 内存区域划分），这是《Java 虚拟机规范》定义的程序运行时数据区，主要描述 JVM 如何划分和管理内存。 Java 内存模型（Java Memory Model，简称 JMM），这是 Java 语言规范（JLS 第 17 章...","head":[["meta",{"property":"og:url","content":"https://hubao-1125.github.io/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/165450/"}],["meta",{"property":"og:site_name","content":"Hu bao's blog"}],["meta",{"property":"og:title","content":"JVM内存模型"}],["meta",{"property":"og:description","content":"JVM 的内存模型详解 在 Java 开发中，“JVM 的内存模型”通常有两种常见指代： JVM 运行时内存结构（也称 JVM 内存区域划分），这是《Java 虚拟机规范》定义的程序运行时数据区，主要描述 JVM 如何划分和管理内存。 Java 内存模型（Java Memory Model，简称 JMM），这是 Java 语言规范（JLS 第 17 章..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-22T09:34:08.000Z"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2025-12-22T09:34:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM内存模型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-22T09:34:08.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":4.34,"words":1301},"git":{"updatedTime":1766396048000,"contributors":[{"name":"hubao-1125","username":"hubao-1125","email":"19473254+hubao-1125@users.noreply.github.com","commits":2,"avatar":"https://avatars.githubusercontent.com/hubao-1125?v=4","url":"https://github.com/hubao-1125"}]},"autoDesc":true,"filePathRelative":"doc/Java/JVM/分代分区/1.JVM内存模型.md","categoryList":[{"id":"9a09b4","sort":10000,"name":"doc"},{"id":"8f1aa6","sort":10001,"name":"Java"},{"id":"000f90","sort":10002,"name":"JVM"},{"id":"2b6b47","sort":10003,"name":"分代分区"}]}`);export{d as comp,p as data};
