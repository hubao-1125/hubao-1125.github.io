import{_ as a,c as n,a as t,o as p}from"./app-Dm747Kgg.js";const e={};function c(l,s){return p(),n("div",null,s[0]||(s[0]=[t(`<p>在Java的JVM内存模型中，“堆（Heap）”和“栈（Stack，通常指虚拟机栈JVM Stack）”是两个核心的内存区域，它们在<strong>定义、作用、管理方式</strong>等方面有显著区别：</p><h3 id="一、核心定义与作用" tabindex="-1"><a class="header-anchor" href="#一、核心定义与作用"><span>一、核心定义与作用</span></a></h3><table><thead><tr><th>维度</th><th>堆（Heap）</th><th>栈（虚拟机栈JVM Stack）</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>JVM管理的最大内存区域，是<strong>对象实例的“主战场”</strong>。</td><td>线程私有的内存区域，是<strong>方法执行的内存模型</strong>，支持方法的调用、执行和返回。</td></tr><tr><td><strong>作用</strong></td><td>存储<strong>对象实例</strong>（如<code>new Object()</code>）和<strong>数组</strong>（如<code>new int[10]</code>）。</td><td>存储<strong>栈帧</strong>（Stack Frame），每个方法调用对应一个栈帧，包含局部变量、操作数栈等。</td></tr></tbody></table><h3 id="二、线程共享性" tabindex="-1"><a class="header-anchor" href="#二、线程共享性"><span>二、线程共享性</span></a></h3><ul><li><strong>堆</strong>：<strong>线程共享</strong>，所有线程可以访问堆中的对象实例（需通过引用）。</li><li><strong>栈</strong>：<strong>线程私有</strong>，每个线程创建时分配独立的栈内存，线程间的栈互不干扰。</li></ul><h3 id="三、存储内容的详细对比" tabindex="-1"><a class="header-anchor" href="#三、存储内容的详细对比"><span>三、存储内容的详细对比</span></a></h3><h4 id="堆的存储内容" tabindex="-1"><a class="header-anchor" href="#堆的存储内容"><span>堆的存储内容</span></a></h4><ul><li>对象实例的<strong>成员变量</strong>（非static变量）。</li><li>数组的<strong>元素</strong>（无论基本类型还是引用类型）。</li><li>注意：对象的<strong>引用</strong>（如<code>Test obj = new Test()</code>中的<code>obj</code>）不存储在堆，而是存储在栈（局部变量）或方法区（类变量）。</li></ul><h4 id="栈的存储内容-栈帧的组成" tabindex="-1"><a class="header-anchor" href="#栈的存储内容-栈帧的组成"><span>栈的存储内容（栈帧的组成）</span></a></h4><ul><li><strong>局部变量表</strong>：方法参数、局部变量（基本类型、对象引用）。</li><li><strong>操作数栈</strong>：方法执行时的临时数据存储区（如运算中间结果）。</li><li><strong>动态链接</strong>：将符号引用转换为直接引用（支持多态）。</li><li><strong>方法出口</strong>：记录方法返回后的执行位置。</li></ul><h3 id="四、内存管理机制" tabindex="-1"><a class="header-anchor" href="#四、内存管理机制"><span>四、内存管理机制</span></a></h3><table><thead><tr><th>维度</th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td><strong>分配方式</strong></td><td>动态分配（对象创建时），大小可通过<code>-Xmx</code>（最大）和<code>-Xms</code>（初始）调整。</td><td>自动分配（方法调用时压入栈帧），大小可通过<code>-Xss</code>参数调整（默认约1MB）。</td></tr><tr><td><strong>回收方式</strong></td><td>由<strong>垃圾回收器（GC）</strong> 自动管理，采用分代回收策略（年轻代、老年代）。</td><td>自动回收（方法执行结束时弹出栈帧），<strong>无需GC介入</strong>，随方法生命周期自动释放。</td></tr><tr><td><strong>溢出异常</strong></td><td>- 堆内存不足时抛出：<code>java.lang.OutOfMemoryError: Java heap space</code>。<br>- 常见原因：对象过多、内存泄漏。</td><td>- 栈深度过深时抛出：<code>java.lang.StackOverflowError</code>（如无限递归）。<br>- 线程过多时抛出：<code>java.lang.OutOfMemoryError: unable to create new native thread</code>。</td></tr></tbody></table><h3 id="五、内存大小与灵活性" tabindex="-1"><a class="header-anchor" href="#五、内存大小与灵活性"><span>五、内存大小与灵活性</span></a></h3><ul><li><strong>堆</strong>：通常较大（GB级别），默认可动态扩展（从<code>-Xms</code>到<code>-Xmx</code>），适合存储大量对象。</li><li><strong>栈</strong>：通常较小（MB级别），单个栈的大小限制严格（避免占用过多内存），适合存储方法执行的临时数据。</li></ul><h3 id="六、分配效率" tabindex="-1"><a class="header-anchor" href="#六、分配效率"><span>六、分配效率</span></a></h3><ul><li><strong>栈</strong>：分配效率极高，直接通过指针偏移完成内存分配（类似数据结构中的栈操作）。</li><li><strong>堆</strong>：分配效率较低，需要GC维护内存碎片、对象标记等，涉及复杂的内存管理逻辑。</li></ul><h3 id="七、典型示例对比" tabindex="-1"><a class="header-anchor" href="#七、典型示例对比"><span>七、典型示例对比</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki material-theme-ocean vp-code"><code><span class="line"><span style="color:#C792EA;">public</span><span class="space"> </span><span style="color:#C792EA;">class</span><span class="space"> </span><span style="color:#FFCB6B;">HeapStackDemo</span><span class="space"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="color:#C792EA;">public</span><span class="space"> </span><span style="color:#C792EA;">static</span><span class="space"> </span><span style="color:#C792EA;">int</span><span class="space"> </span><span style="color:#BABED8;">classVar</span><span class="space"> </span><span style="color:#89DDFF;">=</span><span class="space"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">//</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">类变量，存储在方法区（元空间）</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="color:#C792EA;">public</span><span class="space"> </span><span style="color:#C792EA;">int</span><span class="space"> </span><span style="color:#BABED8;">instanceVar</span><span class="space"> </span><span style="color:#89DDFF;">=</span><span class="space"> </span><span style="color:#F78C6C;">20</span><span style="color:#89DDFF;">;</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">//</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">成员变量，存储在堆（与对象实例绑定）</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="color:#C792EA;">public</span><span class="space"> </span><span style="color:#C792EA;">void</span><span class="space"> </span><span style="color:#82AAFF;">method</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span class="space"> </span><span style="color:#BABED8;font-style:italic;">param</span><span style="color:#89DDFF;">)</span><span class="space"> </span><span style="color:#89DDFF;">{</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">//</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">param是局部变量，存储在栈的局部变量表</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="color:#C792EA;">int</span><span class="space"> </span><span style="color:#BABED8;">localVar</span><span class="space"> </span><span style="color:#89DDFF;">=</span><span class="space"> </span><span style="color:#F78C6C;">30</span><span style="color:#89DDFF;">;</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">//</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">localVar是局部变量，存储在栈的局部变量表</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="color:#C792EA;">HeapStackDemo</span><span class="space"> </span><span style="color:#BABED8;">obj</span><span class="space"> </span><span style="color:#89DDFF;">=</span><span class="space"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span class="space"> </span><span style="color:#82AAFF;">HeapStackDemo</span><span style="color:#89DDFF;">();</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">//</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">obj引用在栈，对象实例及instanceVar在堆</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结-核心区别" tabindex="-1"><a class="header-anchor" href="#总结-核心区别"><span>总结：核心区别</span></a></h3><table><thead><tr><th>对比项</th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td>线程共享</td><td>是</td><td>否（线程私有）</td></tr><tr><td>存储主体</td><td>对象实例、数组</td><td>方法执行的栈帧（局部变量等）</td></tr><tr><td>内存管理</td><td>GC自动回收（分代）</td><td>自动分配回收（随方法生命周期）</td></tr><tr><td>大小范围</td><td>大（GB级），动态扩展</td><td>小（MB级），限制严格</td></tr><tr><td>溢出类型</td><td>OutOfMemoryError（OOM）</td><td>StackOverflowError 或 OOM</td></tr><tr><td>分配效率</td><td>低</td><td>高</td></tr></tbody></table>`,20)]))}const r=a(e,[["render",c],["__file","index.html.vue"]]),d=JSON.parse(`{"path":"/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/151130/","title":"堆栈的区别","lang":"zh-CN","frontmatter":{"title":"堆栈的区别","createTime":"2025/12/23 15:11:30","permalink":"/doc/Java/JVM/分代分区/151130/","copyright":{"author":{"name":"Hu Bao","url":"https://github.com/hubao-1125"}},"tags":["JVM","面试题"],"description":"在Java的JVM内存模型中，“堆（Heap）”和“栈（Stack，通常指虚拟机栈JVM Stack）”是两个核心的内存区域，它们在定义、作用、管理方式等方面有显著区别： 一、核心定义与作用 二、线程共享性 堆：线程共享，所有线程可以访问堆中的对象实例（需通过引用）。 栈：线程私有，每个线程创建时分配独立的栈内存，线程间的栈互不干扰。 三、存储内容的详...","head":[["meta",{"property":"og:url","content":"https://hubao-1125.github.io/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/151130/"}],["meta",{"property":"og:site_name","content":"Hu bao's blog"}],["meta",{"property":"og:title","content":"堆栈的区别"}],["meta",{"property":"og:description","content":"在Java的JVM内存模型中，“堆（Heap）”和“栈（Stack，通常指虚拟机栈JVM Stack）”是两个核心的内存区域，它们在定义、作用、管理方式等方面有显著区别： 一、核心定义与作用 二、线程共享性 堆：线程共享，所有线程可以访问堆中的对象实例（需通过引用）。 栈：线程私有，每个线程创建时分配独立的栈内存，线程间的栈互不干扰。 三、存储内容的详..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-23T09:23:42.000Z"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2025-12-23T09:23:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"堆栈的区别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-23T09:23:42.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":3.24,"words":973},"git":{"updatedTime":1766481822000,"contributors":[{"name":"hubao-1125","username":"hubao-1125","email":"19473254+hubao-1125@users.noreply.github.com","commits":1,"avatar":"https://avatars.githubusercontent.com/hubao-1125?v=4","url":"https://github.com/hubao-1125"}]},"autoDesc":true,"filePathRelative":"doc/Java/JVM/分代分区/13.堆栈的区别.md","categoryList":[{"id":"9a09b4","sort":10000,"name":"doc"},{"id":"8f1aa6","sort":10001,"name":"Java"},{"id":"000f90","sort":10002,"name":"JVM"},{"id":"2b6b47","sort":10003,"name":"分代分区"}]}`);export{r as comp,d as data};
