import{_ as s,c as t,a as e,o as n}from"./app-Dm747Kgg.js";const o={};function l(p,a){return n(),t("div",null,a[0]||(a[0]=[e(`<h3 id="java-堆空间的区域划分" tabindex="-1"><a class="header-anchor" href="#java-堆空间的区域划分"><span>Java 堆空间的区域划分</span></a></h3><p>Java 堆（Heap）是 JVM 中最大的内存区域，用于存储几乎所有的对象实例和数组。堆是所有线程共享的，由垃圾收集器（GC）管理。</p><p>堆空间在逻辑上主要分为<strong>新生代（Young Generation）<strong>和</strong>老年代（Old Generation/Tenured Generation）</strong>。不同 GC 算法的物理划分略有差异，但 HotSpot JVM（最常见的实现）默认采用分代收集，以下是标准划分：</p><h4 id="_1-新生代-young-generation" tabindex="-1"><a class="header-anchor" href="#_1-新生代-young-generation"><span>1. 新生代（Young Generation）</span></a></h4><p>新生代是对象诞生的地方，大多数对象在这里分配，生命周期短，GC 频率高（Minor GC）。</p><p>新生代进一步细分为：</p><ul><li><strong>Eden 区</strong>：新对象主要在这里分配（通过 TLAB 线程本地分配缓冲区加速）。</li><li><strong>Survivor 区</strong>：分为两个等大小的空间 —— <strong>From Survivor</strong> 和 <strong>To Survivor</strong>（也称 S0 和 S1）。 <ul><li>Minor GC 时，Eden + From 中存活的对象被复制到 To 区。</li><li>然后 From 和 To 角色互换。</li><li>对象每经历一次 Minor GC，年龄 +1，达到阈值（默认 15）时晋升到老年代。</li></ul></li></ul><p>新生代占比通常较小（默认约占堆的 1/3），因为对象死亡率高。</p><h4 id="_2-老年代-old-tenured-generation" tabindex="-1"><a class="header-anchor" href="#_2-老年代-old-tenured-generation"><span>2. 老年代（Old/Tenured Generation）</span></a></h4><ul><li>存放经过多次 Minor GC 仍存活的对象（长生命周期对象，如缓存、常量池等）。</li><li>也可能直接分配大对象（超过阈值时避免新生代复制开销）。</li><li>GC 称为 Major GC 或 Full GC，频率低但耗时长（停顿时间较长）。</li></ul><h4 id="_3-其他特殊情况-java-8" tabindex="-1"><a class="header-anchor" href="#_3-其他特殊情况-java-8"><span>3. 其他特殊情况（Java 8+）</span></a></h4><ul><li><strong>Humongous 区</strong>（G1 GC 特有）：用于存放超过 Region 一半大小的超大对象，直接分配在老年代。</li><li>Java 8 之前还有<code>永久代（Permanent Generation）</code>存放类信息和常量池，但Java 8+ 已移除，改为<code>元空间（Metaspace）</code>使用本地内存，不属于堆。</li></ul><h3 id="堆空间常见参数-hotspot-jvm" tabindex="-1"><a class="header-anchor" href="#堆空间常见参数-hotspot-jvm"><span>堆空间常见参数（HotSpot JVM）</span></a></h3><p>通过 <code>-X</code> 或 <code>-XX</code> 参数调整堆大小和比例。常用参数如下表：</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值/示例</th><th>备注</th></tr></thead><tbody><tr><td><code>-Xms</code></td><td>堆初始大小（最小堆）</td><td>如 <code>-Xms512m</code></td><td>启动时分配</td></tr><tr><td><code>-Xmx</code></td><td>堆最大大小</td><td>如 <code>-Xmx2g</code></td><td>不能超过物理内存</td></tr><tr><td><code>-XX:NewSize</code></td><td>新生代初始大小</td><td></td><td>通常不单独设</td></tr><tr><td><code>-XX:MaxNewSize</code></td><td>新生代最大大小</td><td></td><td></td></tr><tr><td><code>-XX:NewRatio</code></td><td>老年代与新生代的比率（老年代 / 新生代）</td><td>默认 2（老年代占 2/3，年轻代 1/3）</td><td>如 <code>-XX:NewRatio=4</code> 表示老:新=4:1</td></tr><tr><td><code>-XX:SurvivorRatio</code></td><td>Eden 与一个 Survivor 的比率（Eden / Survivor）</td><td>默认 8（Eden 占 8/10，两个 Survivor 各 1/10）</td><td>如 <code>-XX:SurvivorRatio=6</code> 表示 Eden:Survivor=6:1</td></tr><tr><td><code>-XX:+UseAdaptiveSizePolicy</code></td><td>启用自适应大小策略（ERP），JVM 根据 GC 情况动态调整新生代和 Survivor 大小</td><td>默认开启（Parallel GC、CMS 等）</td><td>推荐开启</td></tr><tr><td><code>-XX:MaxTenuringThreshold</code></td><td>对象从新生代晋升老年代的最大年龄阈值</td><td>默认 15（范围 0~15）</td><td>可调小减少老年代压力</td></tr><tr><td><code>-XX:+PrintGCDetails</code></td><td>打印详细 GC 日志，便于观察堆区域变化</td><td></td><td>调优必备</td></tr><tr><td><code>-XX:InitialHeapSize</code> / <code>-XX:MaxHeapSize</code></td><td>等同于 -Xms / -Xmx（更规范写法）</td><td></td><td></td></tr></tbody></table><h4 id="典型配置示例" tabindex="-1"><a class="header-anchor" href="#典型配置示例"><span>典型配置示例</span></a></h4><div class="language-bash line-numbers-mode" data-ext="bash" data-title="bash"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki material-theme-ocean vp-code"><code><span class="line"><span style="color:#464B5D;font-style:italic;">#</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">常见生产环境配置</span></span>
<span class="line"><span style="color:#FFCB6B;">-java</span></span>
<span class="line"><span style="color:#FFCB6B;">-Xms4g</span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">#</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">初始堆</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">4GB</span></span>
<span class="line"><span style="color:#FFCB6B;">-Xmx4g</span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">#</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">最大堆</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">4GB（避免动态扩容开销）</span></span>
<span class="line"><span style="color:#FFCB6B;">-XX:NewRatio</span><span style="color:#C3E88D;">=2</span><span class="space"> </span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">#</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">老年代:新生代</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">=</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">2:1</span></span>
<span class="line"><span style="color:#FFCB6B;">-XX:SurvivorRatio</span><span style="color:#C3E88D;">=8</span></span>
<span class="line"><span style="color:#FFCB6B;">-XX:+UseG1GC</span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">#</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">使用</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">G1</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">收集器（Java</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">9+</span><span class="space"> </span><span style="color:#464B5D;font-style:italic;">默认）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="不同-gc-的堆区域差异" tabindex="-1"><a class="header-anchor" href="#不同-gc-的堆区域差异"><span>不同 GC 的堆区域差异</span></a></h3><ul><li><strong>Serial / Parallel GC</strong>：经典新生代 + 老年代划分。</li><li><strong>CMS GC</strong>：类似，但老年代并发收集。</li><li><strong>G1 GC</strong>（Java 9+ 默认）：将堆划分为多个 <strong>Region</strong>（默认 2048 个），逻辑上仍有年轻代/老年代/Survivor/Humongous，但物理上不连续。</li><li><strong>ZGC / Shenandoah</strong>：低停顿 GC，区域划分更灵活。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li><strong>核心区域</strong>：Eden → Survivor (From/To) → Old。</li><li><strong>目标</strong>：新生代快速回收短命对象，老年代存放长寿对象。</li><li><strong>调优原则</strong>：根据应用对象生命周期调整新生代比例，避免频繁 Full GC。</li></ul>`,21)]))}const r=s(o,[["render",l],["__file","index.html.vue"]]),i=JSON.parse(`{"path":"/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/172605/","title":"Java 堆空间有哪些区域和常见参数","lang":"zh-CN","frontmatter":{"title":"Java 堆空间有哪些区域和常见参数","createTime":"2025/12/19 17:26:05","permalink":"/doc/Java/JVM/分代分区/172605/","copyright":{"author":{"name":"Hu Bao","url":"https://github.com/hubao-1125"}},"tags":["JVM","面试题"],"description":"Java 堆空间的区域划分 Java 堆（Heap）是 JVM 中最大的内存区域，用于存储几乎所有的对象实例和数组。堆是所有线程共享的，由垃圾收集器（GC）管理。 堆空间在逻辑上主要分为新生代（Young Generation）和老年代（Old Generation/Tenured Generation）。不同 GC 算法的物理划分略有差异，但 Hot...","head":[["meta",{"property":"og:url","content":"https://hubao-1125.github.io/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/172605/"}],["meta",{"property":"og:site_name","content":"Hu bao's blog"}],["meta",{"property":"og:title","content":"Java 堆空间有哪些区域和常见参数"}],["meta",{"property":"og:description","content":"Java 堆空间的区域划分 Java 堆（Heap）是 JVM 中最大的内存区域，用于存储几乎所有的对象实例和数组。堆是所有线程共享的，由垃圾收集器（GC）管理。 堆空间在逻辑上主要分为新生代（Young Generation）和老年代（Old Generation/Tenured Generation）。不同 GC 算法的物理划分略有差异，但 Hot..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-22T09:34:08.000Z"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2025-12-22T09:34:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 堆空间有哪些区域和常见参数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-22T09:34:08.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":3.29,"words":987},"git":{"updatedTime":1766396048000,"contributors":[{"name":"hubao-1125","username":"hubao-1125","email":"19473254+hubao-1125@users.noreply.github.com","commits":2,"avatar":"https://avatars.githubusercontent.com/hubao-1125?v=4","url":"https://github.com/hubao-1125"}]},"autoDesc":true,"filePathRelative":"doc/Java/JVM/分代分区/2.Java 堆空间有哪些区域和常见参数.md","categoryList":[{"id":"9a09b4","sort":10000,"name":"doc"},{"id":"8f1aa6","sort":10001,"name":"Java"},{"id":"000f90","sort":10002,"name":"JVM"},{"id":"2b6b47","sort":10003,"name":"分代分区"}]}`);export{r as comp,i as data};
