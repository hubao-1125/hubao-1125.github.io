import{_ as e,c as a,a as o,o as r}from"./app-Dm747Kgg.js";const n={};function s(i,t){return r(),a("div",null,t[0]||(t[0]=[o('<p>JVM的永久代（Permanent Generation，简称PermGen）确实会发生垃圾回收，但具体情况需要结合JDK版本和回收条件来分析：</p><h3 id="一、永久代的作用与存储内容" tabindex="-1"><a class="header-anchor" href="#一、永久代的作用与存储内容"><span>一、永久代的作用与存储内容</span></a></h3><p>永久代是JDK 7及之前版本中HotSpot虚拟机内存模型的一部分，主要存储：</p><ul><li><strong>类的元数据</strong>（Class Metadata）：类的结构信息（如字段、方法、接口等）</li><li><strong>常量池</strong>（JDK 7之前，字符串常量池也在此；JDK 7后字符串常量池移至堆）</li><li><strong>方法区</strong>的实现（JDK 8之前，HotSpot用永久代实现方法区）</li></ul><h3 id="二、永久代的垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#二、永久代的垃圾回收机制"><span>二、永久代的垃圾回收机制</span></a></h3><p>永久代的垃圾回收主要针对<strong>不再被使用的类对象</strong>，回收触发条件较严格，需同时满足：</p><ol><li>该类的<strong>所有实例</strong>已被回收（堆中无该类的任何对象）</li><li>加载该类的<strong>ClassLoader已被回收</strong></li><li>该类的<code>java.lang.Class</code>对象<strong>未被任何地方引用</strong>（无法通过反射访问该类）</li></ol><p>当满足上述条件时，JVM会在<strong>Full GC</strong>（老年代回收）时对永久代进行垃圾回收，卸载不再使用的类。</p><h3 id="三、jdk版本差异的影响" tabindex="-1"><a class="header-anchor" href="#三、jdk版本差异的影响"><span>三、JDK版本差异的影响</span></a></h3><ol><li><strong>JDK 7及之前</strong>：永久代存在，其大小通过<code>-XX:PermSize</code>（初始大小）和<code>-XX:MaxPermSize</code>（最大大小）控制。若永久代内存不足，会触发<code>java.lang.OutOfMemoryError: PermGen space</code>。</li><li><strong>JDK 8及之后</strong>：永久代被<strong>元空间（Metaspace）</strong> 取代，元空间使用<strong>本地内存（Native Memory）</strong> 而非JVM堆内存。元空间也会发生垃圾回收（类卸载逻辑与永久代类似），但空间大小更灵活（默认无上限，可通过<code>-XX:MaxMetaspaceSize</code>限制）。</li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li>JDK 7及之前，永久代<strong>会发生垃圾回收</strong>，主要回收不再被引用的类元数据；</li><li>JDK 8及之后，永久代被元空间取代，元空间同样支持垃圾回收，但内存管理机制更灵活。</li></ul><p>因此，永久代（或其继任者元空间）的垃圾回收是JVM内存管理的重要组成部分，用于避免类元数据的内存泄漏。</p>',13)]))}const l=e(n,[["render",s],["__file","index.html.vue"]]),p=JSON.parse(`{"path":"/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/140835/","title":"JVM的永久代（元空间）会发生垃圾回收吗","lang":"zh-CN","frontmatter":{"title":"JVM的永久代（元空间）会发生垃圾回收吗","createTime":"2025/12/23 14:08:35","permalink":"/doc/Java/JVM/分代分区/140835/","copyright":{"author":{"name":"Hu Bao","url":"https://github.com/hubao-1125"}},"tags":["JVM","面试题"],"description":"JVM的永久代（Permanent Generation，简称PermGen）确实会发生垃圾回收，但具体情况需要结合JDK版本和回收条件来分析： 一、永久代的作用与存储内容 永久代是JDK 7及之前版本中HotSpot虚拟机内存模型的一部分，主要存储： 类的元数据（Class Metadata）：类的结构信息（如字段、方法、接口等） 常量池（JDK 7...","head":[["meta",{"property":"og:url","content":"https://hubao-1125.github.io/doc/Java/JVM/%E5%88%86%E4%BB%A3%E5%88%86%E5%8C%BA/140835/"}],["meta",{"property":"og:site_name","content":"Hu bao's blog"}],["meta",{"property":"og:title","content":"JVM的永久代（元空间）会发生垃圾回收吗"}],["meta",{"property":"og:description","content":"JVM的永久代（Permanent Generation，简称PermGen）确实会发生垃圾回收，但具体情况需要结合JDK版本和回收条件来分析： 一、永久代的作用与存储内容 永久代是JDK 7及之前版本中HotSpot虚拟机内存模型的一部分，主要存储： 类的元数据（Class Metadata）：类的结构信息（如字段、方法、接口等） 常量池（JDK 7..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-23T06:34:42.000Z"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:modified_time","content":"2025-12-23T06:34:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM的永久代（元空间）会发生垃圾回收吗\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-23T06:34:42.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":1.9,"words":571},"git":{"updatedTime":1766471682000,"contributors":[{"name":"hubao-1125","username":"hubao-1125","email":"19473254+hubao-1125@users.noreply.github.com","commits":1,"avatar":"https://avatars.githubusercontent.com/hubao-1125?v=4","url":"https://github.com/hubao-1125"}]},"autoDesc":true,"filePathRelative":"doc/Java/JVM/分代分区/5.JVM的永久代（元空间）会发生垃圾回收吗.md","categoryList":[{"id":"9a09b4","sort":10000,"name":"doc"},{"id":"8f1aa6","sort":10001,"name":"Java"},{"id":"000f90","sort":10002,"name":"JVM"},{"id":"2b6b47","sort":10003,"name":"分代分区"}]}`);export{l as comp,p as data};
